<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.386">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Shifa Maqsood">
<meta name="keywords" content="Self Reference Effect, Retrieval">

<title>Is The Self Reference Effect a Retrieval Practice Phenomenon?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="Thesis_files/libs/clipboard/clipboard.min.js"></script>
<script src="Thesis_files/libs/quarto-html/quarto.js"></script>
<script src="Thesis_files/libs/quarto-html/popper.min.js"></script>
<script src="Thesis_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Thesis_files/libs/quarto-html/anchor.min.js"></script>
<link href="Thesis_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Thesis_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Thesis_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Thesis_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Thesis_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Is The Self Reference Effect a Retrieval Practice Phenomenon?</h1>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Author</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author">Shifa Maqsood <a href="mailto:shifa_maqsood@hotmail.com" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> </p>
  </div>
    <div class="quarto-title-meta-contents">
        <p class="affiliation">
            1
          </p>
      </div>
    </div>

<div class="quarto-title-meta">

      
  
    
  </div>
  
<div>
  <div class="abstract">
    <div class="block-title">Abstract</div>
    <p>In levels of processing framework, Craik and Tulving (1975)’s experiments results demonstrated that subjects recalled more of the words which were encoded under the semantic tasks than other encoding conditons as semantic tasks require elaborate analysis of stimulus than judging the size of it.In 1977, Rogers et al.&nbsp;conducted an experiment in which self-reference effect was found to have led to superior recall. Subsequent research on underlying mechanisms of SRE have led to inconclusion. The present study takes a different perspective at why SRE promotes learning and proposes that the SRE effect emerges as a retrieval practice phenomenon as self is frequently engaged to recall information. We hypothesized that if participants pratice recall of the words during study, there will be no difference between the self and other conditions. Our second hypothesis stated that retrieval pratice will only enahnce the existing differences in each conditon. The results revealed that practicing recall does not help produce more words at the end and there was no self reference effect observed in no-recall condition. We infer that if there had been more delay in time, retrieval pratice would have led to superior retention of the stimuli. It is also possible that our sample size was too small and that participants did not follow instructions. Future research will focus on conductitng the experiment on Brooklyn College students.</p>
  </div>
</div>

<div>
  <div class="keywords">
    <div class="block-title">Keywords</div>
    <p>Self Reference Effect, Retrieval</p>
  </div>
</div>

</header>


<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Seed for random number generation</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">42</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span>opts_chunk<span class="sc">$</span><span class="fu">set</span>(<span class="at">cache.extra =</span> knitr<span class="sc">::</span>rand_seed,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>                      <span class="at">warning =</span> <span class="cn">FALSE</span>,</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>                      <span class="at">echo =</span> <span class="cn">FALSE</span>,</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>                      <span class="at">message=</span> <span class="cn">FALSE</span>,</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>                      <span class="at">error =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Memory performance can be enhanced by mnemonic devices that help learners retain information for later recall. A few effective devices include the method of loci, acronyms, and alphabetic cuing. The method of loci involves associating an arbitrary list of to-be-remembered items with the spatial layout or locations of a familiar place. For example, in the case of memorizing a grocery list of items, one could imagine walking through rooms in their house and mentally place each item on the grocery list in different rooms. When later at the grocery store, the list of items can be recalled by mentally simulating walking through the rooms, each of which would act as an effective retrieval cue for a grocery item.. Acronyms are a device that involve arranging the first letters of a list of to-be-remembered words to form a new memorable word. For example, each letter in “ROY G. BIV” is used to refer to the colors on the visible spectrum. (Nelson &amp; Archer, 1972). Similarly, alphabetic cueing is a device that may help people recover from momentary memory lapses, like tip-of-the tongue, where a person knows a word or name, but is unable to recall it. Alphabetic cuing involves systematically asking whether the word begins with “a”, or “b”, and so on. The process of considering each letter one at a time systematically varies the retrieval cue, and can lead to successful recall. This thesis examines theoretical accounts of a mnemonic device called the self-reference effect that has been forwarded as a particularly powerful memory aid.</p>
<section id="the-self-reference-effect" class="level1">
<h1>The self reference effect</h1>
<p>All of the above mnemonic devices provide support for a very general memory principle: making information meaningful makes it more memorable (Bransford &amp; Johnson, 1972). The self-reference effect provides an example of this principle that may directly tap a deep source of meaning for individuals. Simply put, prior research on the self-reference effect suggests that the act of relating an item to oneself makes the item more memorable. This finding is consistent with theories suggesting that the self is a complex and dynamic process that gives meaning to new experiences by relating them to past experiences (Markus). So, the act of considering something in relation to the self may therefore imbue the object or thought with multiple layers of meaning leading to an enhancement in memorability.</p>
<p>Prior research has found a robust self-reference effect however explanations of the phenomenon have been inconclusive. Most prior research assumes that the effect of self-reference strengthens a memory trace while it is encoded. The purpose of this thesis is to propose and examine an alternative explanation for the self-reference effect that suggests a role for memory retrieval processes.</p>
</section>
<section id="evidence-for-the-self-reference-effect" class="level1">
<h1>Evidence for the self-reference effect</h1>
<p>The phenomenon of the well-replicated self-reference effect wasobserved by Rogers et al.&nbsp;(1977). Their experiments were intended to further evaluate Craik and Lockhart’s’s (X) levels of processing principle to determine whether relating information to oneself could promote deeper processing and enhance memorability. Previous results supporting the levels of processing principle had shown that memory for words depended on “depth” of processing during encoding. For example, Craik &amp; Tulving (1975) showed participants words for a later memory test, but systematically varied how the words were encoded using a word judgment task. Some judgments were about physical (letter size) or acoustic (rhyming) properties of the words, and others were about category membership or whether the word would fit meaningfully in a sentence. Memory performance improved for words that were given deeper levels of encoding (e.g., category and sentence judgments) compared to more shallow levels of encoding (e.g., physical and acoustic judgments). Broadly speaking, Craik &amp; Tulving demonstrated that encoding words in a more than less meaningful way improved memory for those words.</p>
<p>Rogers et al.&nbsp;() extended Craik &amp; Tulving’s design to test whether deeper levels of processing could be achieved using a self-reference judgment task. The laboratory experiment included 40 personality trait adjectives which were presented on a computer screen one at a time along with a cue, in the form of a question, asking participants to make a judgment about the adjective. There were four judgment tasks: structural, phonemic, semantic, and self-reference. In the structural task, participants judged whether the physical size of the letters was the same size as the cue question. In the phonemic task, participants judged whether the adjective rhymed with another word in the cue question. In the semantic task, participants judged whether the adjective had the same meaning as another word in the cue question. Last, in the self-reference task, participants judged whether the adjective described themselves or not. Each cue question was followed by a 500-ms interval and then the target adjective was presented.. Participants were instructed to respond “yes” or “no” by pressing a button.After the encoding phase, participants were asked to recall as many words as possible.</p>
<p>Rogers et al.&nbsp;found evidence consistent with the levels of processing principle. The number of words recalled was the least for the structural condition, slightly more in the rhyming condition, more yet in the semantic condition, and the most in the self-reference condition. Furthermore, there was a significant difference between the self-reference and semantic conditions, suggesting that the self-reference manipulation caused a deeper level of more meaningful processing than the already effective semantic condition.</p>
<p>Participants gave the same ‘yes’ or ‘no’ response in all judgment tasks, and another finding was that recall memory was better for ‘yes’ than ‘no’ response words. This finding suggests that the self-reference effect is enhanced when subjects agreed that the adjective did describe themselves. The basic pattern of results was also replicated in a second experiment using a modifying design involving a rating scale rather than a yes/no judgment.</p>
</section>
<section id="replicating-the-self-reference-effect" class="level1">
<h1>Replicating the self-reference effect</h1>
<p>Subsequent variations of Roger’s et al study th provide evidence that self-reference may be a superior encoding device. A meta-analysis on the Self-Reference Effect aimed to present their literature review of SRE which focused on conditions in which the self-reference occurs which distinguishes it from semantic processing and other-person references. Other person reference is a task in SR paradigm in which the participant judges whether the trait adjective applies to the familiar person. It can be a familiar celebrity or a highly intimate person such as one’s mother. To be consistent in their analysis, they only included studies which followed the standard Depth of Processing paradigm in which there is an encoding question followed by a stimulus. Some of the characteristics of these 129 studies were that they used 39 participants on average, undergraduates being the majority of the participant population. The studies used within-subjects 75% of times and used between subjects design 25% of the times. These studies also primarily used free call in their designs and trait adjectives.</p>
<p>The effect size of 0.45 supported their hypothesis that SRE did promote greater recall than other person reference or semantic tasks. Although SRE was smaller when the other person was intimate such as the person’s mother, yet SR still performed better across the studies.</p>
<p>The Self-reference paradigm experiments have mostly been conducted in laboratories in which the majority of the participants were undergraduates and the average sample size of a study was 39. In order to promote the accessibility of the self-referential paradigm Bently et al replicated the 1977’s standard self-reference effect as an online experiment through Amazon Mechanical Turk (MTurk). They expected the online version would allow the researchers to study larger sample sizes and not just be limited to undergrad populations. There were four versions/variations of the standard self-reference experiment. Study 1 was a direct replication of Rogers et al self-reference experiment with the exception that participants could proceed to the next question on their own and not wait for five seconds for each question. There was also a filler task at the end of the encoding phase before the recall. Conservative analysis of the results showed that there was not a significant difference in mean recall of words between SR and semantic tasks. It was inferred that participants did not spend more time during encoding. Study 2 tested this inference and instead each question was set to be present for five seconds. The longer duration of stimulus resulted in participants engaging deeply with stimulus as the conservative analyses showed were more self-referent words recalled than the words in semantic tasks. Study 3 in addition to the standard self reference paradigm tested the effect of recognition and free recall on memory recall. Results showed that in recognition condition, self reference effect was diminished as there was no significant difference between semantic and self reference. The study 4 tested if the recall of the trait adjectives across the encoding tasks is affected by prior knowledge of the recall. There was no significant difference between incidental and informed recall conditions.</p>
<!-- 

(the point of this section is to demonstrate that many researchers have replicated the self-reference effect, and there appears to be a decent amount of literature support for this phenomena).

Need one/two paragraphs on the meta-analysis

- What was the meta-analysis? How many studies?
- Summarize some of the main attributes of SRE studies from pg 377 of the meta-analysis
- Describe the main conclusion. Across studies there is a SRE and it is typically greater than OR or semantic encoding

One paragraph on the recent online replication (Bentley)
- A little bit of foreshadowing here, as we will be using an online design

-->
</section>
<section id="extensions-and-applications-of-the-self-reference-effect" class="level1">
<h1>Extensions and applications of the self-reference effect</h1>
<p>Self reference may be a useful mnemonic device in educational settings to promote meaningful learning. For example, children in primary school were able to retain a list of words better when they used themselves as subjects in relation to the to-be-remembered words in sentences. Spelling accuracy was also judged to be higher in self-reference conditions than other-referent conditions ( turk et al 2015).</p>
<p>People may engage in self-referential processing even without an explicit instruction to link a current stimulus with the self. Turk et al 2008 included an incidental condition in which the participants were only instructed to respond if the stimuli was placed above or below the cue. The referent cue was either the image or name of the participant or an image or name of a well known celebrity. The findings showed participants remembered adjectives associated with themselves more than the other in the incidental condition. (Turk et al 2008). Bower et al observed that there was also no difference in recall in the self-reference condition between adjective traits and event description task . Participants were able to recall an incident from their autobiographical memory when they were asked if an adjective noun phrase (e.g.&nbsp;broken bone) referred to a personal experience. . However, other experiments have deviated from the usage of adjectives only and they have instead tried to demonstrate the use of self-reference in everyday life. In one study, for example, participants were instructed to retain as much as information about profiles of unknown people. They were then instructed to recall as much as information they could remember about the profiles. Results showed that the subjects correctly remembered birthdays of the unknown people that were in the same month as their own birthday. (kesebit, 2008).</p>
<p>Neuroimaging techniques such as fMri have also been utilized to investigate and locate the neural correlates of the self. The medial prefrontal cortex along with other brain regions including anterior cingulate were found to be activated during the self-reference trials during the experiment t. (Macrae, 2004). The activity of medial prefrontal cortex was found to have been active during encoding and for the remembered words which suggests its role in memory formation. (macrae, 2004). A meta-analysis of self- referential processing in the brain reveals that cortical midline structures which also include medial prefrontal cortex were found to be active during self related tasks during a number of domains such as verbal, spatial and emotional domains. (Northoff, 2006).</p>
<!-- compress this conclusion paragraph -->
<p>Since the initial observance of the phenomenon of the self-reference effect, it has been considerably demonstrated in the following studies to have produced superior recall than semantic and other encoding tasks.The literature review has shown that SRE can reliably improve recall in subjects over other encoding tasks such as semantic tasks. In fact, the meta-analysis across the self-reference effect literature has also shown that despite the increase in memory load (the amount of information to be remembered), SR proved to be comparatively more efficient than semantic encoding in some study designs, (seymons,). As yet, the self-reference effect has been found in a variety of manipulations of the standard self-reference paradigm; however, the underlying mechanisms which facilitate this cognitive process have not been well understood.</p>
</section>
<section id="theoretical-explanations-of-the-self-reference-effect" class="level1">
<h1>Theoretical explanations of the self-reference effect</h1>
<p>What makes relating information to yourself more memorable? This section describes major theoretical explanations of the self-reference effect. First, theories that focus on encoding processes are reviewed, followed by theories that focus on retrieval processes. The section concludes with a novel retrieval focused theory that sets the stage for the experiments presented in the thesis.</p>
<section id="encoding-focused-theories-of-the-sre" class="level2">
<h2 class="anchored" data-anchor-id="encoding-focused-theories-of-the-sre">Encoding focused theories of the SRE</h2>
<p>As previously mentioned, the Rogers et al.&nbsp;study was an attempt to replicate and extend Craik and Tulving (1975) empirical work providing evidence for the levels of processing principle (Craik &amp; Lockhart, 1972). The levels of processing principle is the very general idea that memorability is influenced by depth of processing during encoding. Specifically, deeper processing during encoding yields better memory performance. For example, in the Craik and Tulving experiments, participants were presumed to encode words in the semantic conditions more deeply than words in the physical attribute or rhyming conditions. Similarly, . in the self-reference effect, relating information to oneself may cause an even deeper level of processing than the Craik &amp; Tulving ‘semantics’ condition. On this view, the self-reference effect occurs because relating information to oneself strengthens the memory trace through a deep level of meaningful processing. The strengthened trace is less vulnerable to decay and more available for later recall.</p>
<p>Organizational encoding processes have also been forwarded as an explanation of the self-reference effect. Klein and Khilstrom () posited that self reference promotes categorical organization as the participants organize the words into two categories during the encoding phase: words that describe them and words that do not describe them. The act of categorizing words during encoding was assumed to provide additional cues that would facilitate later recall. They provided support for this idea by showing no difference in recall when semantics and self-reference were both equated to promote active categorization of list words. (klein and khilstrom).</p>
<p>Nevertheless, it can not be argued that organization is solely responsible for self-referential processing since non-depressed subjects remembered more non-depressed content than mildly depressed subjects who remembered both non-depressed and depressed content in a study (kuiper,1981). These findings support a role for elaboration processes in the self-reference effect. For example, mildly depressed subjects remembered more depressed adjectives than non-depressed subjects. This finding is consistent with the idea that depressed adjectives were recalled more because they were compatible with the self-schema of the depressed individuals leaving an elaborate trace for recall (kuiper, 1981). Therefore, it is possible that both, elaborative and organizational processes contribute to great recall of self-referential information.</p>
<p>Klein and Loftus in 1988 found that self-reference tasks performed similar to both organizational and elaborative processes, however they were unable to infer to which degree either process contributes to the SRE. In elaborative processing, the word is encoded in reference to “item-specific” information present in the memory which leads to more than one retrieval route established for each stimulus word during encoding for later recall. Whereas in organization processing, the stimulus list words are organized in category labels in a relation to each other which are later recalled in a cluster. (KLEIN AND LOFTUS).</p>
<p>There have been other attempts to understand the basis for SRE, one of which was proposed by Ganellen who argues for several other mediators being responsible for the incidental encoding induced by the self-reference effect. Ganellen hypothesized that the self-referent encoding is dependent on the emotions the stimulus produces during encoding, the importance of the stimulus to the subject and its distinctiveness. However their results yielded no relation of these predictor variables to the self-reference effect in their experiment which led to the possible implication that cognitive processes underlying self-reference are distinct from judgmental or emotional processes. (ganellan, 1985). Diverging from the depth of processing paradigm, Bellezaa proposed self-schema as an organization of internal cues which then associate personal experiences with new information and these cues are then retrieved during recall; however Bellezza’s 1984’s findings surprisingly showed that participants only recalled only about half of the trait words they had associated with their personal experiences. . To conclude, the research on the processes behind the self-reference seems to be inconclusive despite it being a robust phenomenon which has been replicated in many studies.</p>
</section>
<section id="retrieval-focused-theories-of-the-sre" class="level2">
<h2 class="anchored" data-anchor-id="retrieval-focused-theories-of-the-sre">Retrieval focused theories of the SRE</h2>
<p>There has been more emphasis on encoding than retrieval processes in the self-reference effect. Retrieval refers to the processes that are involved in attempts to bring information from the past to mind in the current context. In general, retrieval of memory traces is facilitated when cues in the current context match well with cues from the encoding context, and retrieval is impaired when cues between the current context and a previous one mismatch. This matching rule is supported by context-dependent memory phenomena (), the encoding specificity principles, and the transfer-appropriate processing principle ().</p>
<p>This thesis proposes that retrieval processes may play an important role in the self-reference effect. For example, according to the matching rule, participants will have better recall when the retrieval context matches well with the encoding context. In general, studies of the self-reference effect do not manipulate retrieval conditions. Typical studies involve a free-recall phase where participants generate as many words from the study list as possible. During this phase participants are free to rely on any cues, including self-generated ones, to prompt recall. If participants were naturally biased toward thinking about themselves during the recall phase, this bias would match well with words presented in the self-reference condition, and could provide additional support for retrieving words in the self-reference condition compared to other conditions.</p>
<p>Retrieval processes may also be involved during the encoding phase. For example, retrieval practice is known to improve memorability more than multiple study attempts. For example, Roediger &amp; Karpicke (2006) had participants study paragraphs about undergraduate level concepts. Some paragraphs were allowed to be studied twice, and other paragraphs were only studied once followed by a quiz about the concepts. They found that concepts that were quizzed were better remembered over the long term than concepts that were studied twice. A general interpretation of the retrieval practice effect is that remembering a piece of information is like a skill that requires specific cognitive actions. Quizzes prompts people to engage in the specific actions necessary to retrieve information, and this form of practice develops the skill necessary to retrieve the information at a later date.</p>
<p>A related explanation is that as the learner tries to bring the information to their mind during each test, the diagnosticity of the retrieval cues improves by the strengthening of the match between the cue and its target. (Karpicke, 2102). Proponents of elaborative encoding have argued that elaboration of the stimuli during retrieval produces mediators and additional retrieval cues which facilitate the recall during testing. However, Karpicke and Smith (2012) observed that retrieval practice is a separate mechanism which can not be attributed to elaborative encoding. In their experiment 4, there were identical twin pairs presented during learning to inhibit mediators and the repeated retrieval condition score was reported to be 99.6%. Furthermore, retrieval practice also produced higher recall than elaborative studying even when subjects were instructed to draw concept maps, which are largely associated with elaboration, at the final test. (Karpicke and Blunt, 2011).</p>
<p>This thesis proposes and tests the possibility that the retrieval practice may be contributing to the self-reference effect. Specifically, it is possible that the self-reference encoding condition is confounded with retrieval practice. For example, consider the subjective experience involved in a typical self-reference judgment asking participants to judge whether an adjective, such as NICE, describes themselves. Participants may begin an internal narrative asking themselves, “Am I nice?”, “Maybe, I’m nice, but I’m not that nice”, etc. This narrative involves repeatedly stating the to-be-remembered word, which provides multiple retrieval practice attempts. Participants may not engage in such a complex inner monologue for the other conditions, especially when the judgment can be made more directly. On this view, the self-reference effect could reflect an advantage for words that were given retrieval practice in the self-reference condition compared to words that were not practiced in the other conditions. The purpose of the experiments reported in this thesis is to investigate this hypothesis directly by explicitly manipulating retrieval practice across all conditions.</p>
</section>
</section>
<section id="experiment-1a-pilot" class="level1">
<h1>Experiment 1a: Pilot</h1>
<p>The first experiment was designed to test the hypothesis that the self-reference effect may reflect a confound due to retrieval practice. The design closely resembled the first experiment from <span class="citation" data-cites="rogers_self-reference_1977">Rogers, Kuiper, and Kirker (<a href="#ref-rogers_self-reference_1977" role="doc-biblioref">1977</a>)</span>. Participants were presented with trait adjectives during an encoding phase followed by free recall. During the encoding phase each word was paired with one of three judgment tasks: letter case, semantic, and self-reference. The novel manipulation was to explicitly manipulate retrieval practice during the encoding phase for half of the words. For example, half of the encoding trials were followed by a secondary n-1 recall task, where participants were instructed to recall the previous word they had judged on the immediately preceding trial.</p>
<p>Predictions for performance based on the major hypothesis are shown in Figure @ref(fig:predictdions).</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Thesis_files/figure-html/predictions-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>Predicted number of words recalled for retrieval practice and study instruction conditions for different hypothetical outcomes.</figcaption>
</figure>
</div>
</div>
</div>
<p>In the no retrieval practice condition we expected to replicate the standard self-reference effect. Specifically, we expected recall rates to increase with depth encoding, such that recall would be highest in the self-reference condition, and lowest in the case-judgment condition (case &lt; semantic &lt; self).</p>
<p>In the retrieval practice condition we considered two possible outcomes. First, it is possible that participants already engage in retrieval practice (by mentally repeating the word) for words in the self-reference condition; and, that they do not engage in retrieval practice for the case or semantic judgments (which can be answered immediately without mentally repeating the word). In this case, retrieval practice may improve recall for words in the case and semantic conditions compared to the self-reference condition which may already be benefitting from retrieval practice. An outcome could be improved and potentially equivalent recall in all conditions (case = semantic = self). In other words, if the self-reference condition has superior recall rates because of retrieval practice, then we expected that delivering retrieval practice for items in the case and semantic conditions would improve recallability to the level of the self-reference condition.</p>
<p>Another possibility is that retrieval practice benefits recall for all words in all conditions. Here, we might expect a main effect of retrieval practice, and no interaction with the encoding question factor.</p>
<p>Experiment 1a is considered a pilot experiment. To foreshadow the results, the participants recruited from Amazon’s Mechanical Turk did not provide trustworthy data. The design and participant recruitment is improved upon in the remaining experiments.</p>
<section id="methods" class="level2">
<h2 class="anchored" data-anchor-id="methods">Methods</h2>
<section id="participants." class="level3">
<h3 class="anchored" data-anchor-id="participants.">Participants.</h3>
<p>Participants were recruited from Amazon’s Mechanical Turk, but due to several issues it was unclear how many human participants were recruited. The experiment was approved by the Brooklyn College Institutional Review Board.</p>
</section>
<section id="materials." class="level3">
<h3 class="anchored" data-anchor-id="materials.">Materials.</h3>
<p>A list of person-descriptive words was obtained from <span class="citation" data-cites="chandler2018">(<a href="#ref-chandler2018" role="doc-biblioref"><strong>chandler2018?</strong></a>)</span>. The list of words was filtered to exclude any words containing punctuation, and words considered derogatory and otherwise objectionable. The total stimulus set had 375 words. These words were categorized by <span class="citation" data-cites="chandler2018">(<a href="#ref-chandler2018" role="doc-biblioref"><strong>chandler2018?</strong></a>)</span> in terms of likeableness. There were 173 high likeable words, and 202 low likeable words.</p>
</section>
<section id="design." class="level3">
<h3 class="anchored" data-anchor-id="design.">Design.</h3>
<p>This experimental design was a 3x2x2 mixed factorial. The encoding judgment task was a within-subject factor with three levels: structural, semantic, and self-reference. Retrieval practice was also a within-subjects factor involving two leves: retrieval practice vs.&nbsp;no retrieval practice. Last the encoding judgment tasks were presented to participants in either a blocked or mixed design. The dependent variable was the number of words recalled.</p>
<p>12 unique words (6 high, and 6 low likeable) for were randomly chosen from the stimulus set for each of the three conditions (36 words in total). Four additional filler items were inserted at the beginning and end of the encoding phase. The intention was to randomly assign half of the words for each judgment task to the retrieval practice condition, and the other half to the no-retrieval practice condition. However, a mistake in the script caused the .33 of the words to be assigned to the retrieval practice condition and .67 words to the no-retrieval practice condition. This error was corrected in the following experiments.</p>
</section>
<section id="apparatus." class="level3">
<h3 class="anchored" data-anchor-id="apparatus.">Apparatus.</h3>
<p>The experiment was programmed using in JavaScript and HTML using JsPsych (De Leeuw, 2015). Just Another Tool for Online Studies (JATOS) was used to host this experiment online [cite jatos]. The source code for the experiments is available from the project website.</p>
</section>
<section id="procedure." class="level3">
<h3 class="anchored" data-anchor-id="procedure.">Procedure.</h3>
<p>Participants were recruited from Amazon’s Mechanical Turk. They completed a consent form followed by a demographics questionnaire and task instructions. The task instructions stated, “In this phase you will make judgments about words that describe personality characteristics or traits. Sometimes you will be asked to remember words that were just shown to you. There are 44 words to judge. After this phase you will be given a memory test for all of the words you saw. Press any key to begin.”</p>
<p>Following the instructions, participants completed the encoding phase. On each trial a cue question indicating the word judgment task was presented on screen for 3000 ms. There were three possible cue questions: “Is the following word written in upper case?”, “Does the following word have a positive meaning?”, and “Would you use the following word to describe yourself?”. Next, the target word appeared on screen underneath the cue question, along with two buttons to respond “yes” or “no”, all of which remained on screen until a response was made. There was an inter-trial interval of 1000 ms. For words assigned to the retrieval practice condition a recall prompt appeared prior to the next trial. The recall prompt stated, “Recall the last word, Type the last word that you judged.” Participants were shown a box with a cursor and proceeded to type their response. They pressed a button to continue to the next trial. There were a total of 44 encoding trials.</p>
<p>In phase 2 of the experiment, participants were instructed to recall all the words they could. Participants were shown an instruction screen stating, “Phase II instructions. In this phase you will be given a recall memory test. You made judgments about 44 words. Your task is now to recall as many words as you can by typing out each word. Press any key to begin.” Next participants were shown a screen with instructions and a text entry box. The instructions read, “Recall each word. You were shown 44 words, try to recall as many words as possible. Type each word separated by a space. Your responses will be shown in the box below.”</p>
<p>Participants pressed a button to continue when they could not recall additional words. At this time, a second free recall phase began asking participants to try one more time to recall any additional words. The experiment ended after the final recall phase.</p>
</section>
<section id="data-exclusion." class="level3">
<h3 class="anchored" data-anchor-id="data-exclusion.">Data-Exclusion.</h3>
<p>Our experiment was conducted online and it was completed by participants on their web browsers. Although there were specific instructions at the beginning of the experiment, there was a possibility that participants completed and submitted the experiment without following the instructions. Thus, we set criteria for excluding those participants whose responses indicated that they did not follow the instructions to complete the tasks. During the study phase, part one of the experiment, participants were instructed to click on either, “Yes” or “No” button. There were three conditions: structural, semantics and self. In the structural condition, the questions asked if the word displayed on screen was in uppercase or lowercase. We judged the response to the questions in this condition to be the baseline for our criteria as this condition served as the participant’s ability to attend to instructions. We excluded participants who scored lower than 70% on structural judgement questions. A total of 16 participants were excluded. We also checked for response bias as to make sure that the participants were not randomly choosing the Yes or No option as their responses to the question.</p>
</section>
</section>
<section id="results-and-discussion" class="level2">
<h2 class="anchored" data-anchor-id="results-and-discussion">Results and Discussion</h2>
<p>The data analysis suggested that many of the participants may not have been completing the study as intended. First, a large proportion of participants were scored at or near chance on the letter size judgment task. Second, recall rates were very low overall, and several participants typed nonsense responses. Third, the response patterns suggested that some number of participants were completing the experiment multiple times under different user names. The data collected for the pilot study also revealed an error in the program which did not assign an equal number of trials to the retrieval practice and no-retrieval practice conditions. For these reasons, the data for the pilot study are not reported.</p>
<p>There are several known issues with recruiting participants from Amazon’s Mechanical Turk (see ), and these are given additional consideration in the general discussion. The pilot experiment recruited participants with minimal filtering. The next experiment addressed these issues.</p>
</section>
</section>
<section id="experiment-1b-and-1c" class="level1">
<h1>Experiment 1b and 1c</h1>
<p>Experiment 1b and 1c were the same as the pilot experiment with the following exceptions. Experiment 1b recruited participants from Amazon’s Mechanical Turk using different filters than the pilot experiment. Experiment 1c recruited participants from the Brooklyn College undergraduate community. Additionally, for both experiments the experiment script was fixed such that there were an equal number of retrieval practice and no-retrieval practice trials within each encoding condition.</p>
<p>In addition, experiment 1b and 1c included further instructions that participants should not use memory aids such as writing down words during the experiment. And, the experiment concluded with a series of debriefing questions.</p>
<section id="methods-1" class="level2">
<h2 class="anchored" data-anchor-id="methods-1">Methods</h2>
<section id="participants.-1" class="level3">
<h3 class="anchored" data-anchor-id="participants.-1">Participants.</h3>
</section>
<section id="materials.-1" class="level3">
<h3 class="anchored" data-anchor-id="materials.-1">Materials.</h3>
<p>The same materials as described in the pilot experiment were used in experiment 1b and 1c.</p>
</section>
<section id="design.-1" class="level3">
<h3 class="anchored" data-anchor-id="design.-1">Design.</h3>
<p>The same 3x2x2 mixed factorial design as described in the pilot experiment was used in experiments 1b and 1c.</p>
</section>
<section id="apparatus.-1" class="level3">
<h3 class="anchored" data-anchor-id="apparatus.-1">Apparatus.</h3>
<p>The apparatus was the same as the pilot experiment.</p>
</section>
<section id="procedure.-1" class="level3">
<h3 class="anchored" data-anchor-id="procedure.-1">Procedure.</h3>
<p>The procedure was the same as before with the following differences.</p>
<p>The instructions given during the encoding phase further specified that, “Important. There is a memory test after this phase. Please do not use external aids to help your performance. For example, please do not write down the words or take screenshots. The experiment is aimed at measuring unaided memory processes. Press any key to begin.”</p>
<p>At the end of the experiment participants were presented with the following debriefing statement and questions: “Thanks for participating, we are planning on running similar experiments in the future, and we are interested in your feedback. Did you use any external memory aids like writing down the words or taking screenshots? Thanks for letting us know. Were you able to give this task your full attention, or did you get interrupted? Thanks for letting us know. Did you run into issues with the task, or other issues that might have impacted your performance?”</p>
</section>
<section id="data-exclusion.-1" class="level3">
<h3 class="anchored" data-anchor-id="data-exclusion.-1">Data-Exclusion.</h3>
<p>We used the same exclusion procedure as described previously. X participants were removed from experiment 1b and X participants were removed from experiment 1c.</p>
<p>We used R <span class="citation" data-cites="R-base">(Version 4.3.1; <a href="#ref-R-base" role="doc-biblioref">R Core Team 2022</a>)</span> and the R-packages <em>data.table</em> <span class="citation" data-cites="R-data.table">(Version 1.14.8; <a href="#ref-R-data.table" role="doc-biblioref">Dowle and Srinivasan 2022</a>)</span>, <em>dplyr</em> <span class="citation" data-cites="R-dplyr">(Version 1.1.2; <a href="#ref-R-dplyr" role="doc-biblioref">Wickham et al. 2023</a>)</span>, <em>forcats</em> <span class="citation" data-cites="R-forcats">(Version 1.0.0; <a href="#ref-R-forcats" role="doc-biblioref">Wickham 2023</a>)</span>, <em>ggplot2</em> <span class="citation" data-cites="R-ggplot2">(Version 3.4.2; <a href="#ref-R-ggplot2" role="doc-biblioref">Wickham 2016</a>)</span>, <em>jsonlite</em> <span class="citation" data-cites="R-jsonlite">(Version 1.8.7; <a href="#ref-R-jsonlite" role="doc-biblioref">Ooms 2014</a>)</span>, <em>lubridate</em> <span class="citation" data-cites="R-lubridate">(Version 1.9.2; <a href="#ref-R-lubridate" role="doc-biblioref">Grolemund and Wickham 2011</a>)</span>, <em>papaja</em> <span class="citation" data-cites="R-papaja">(Version 0.1.1; <a href="#ref-R-papaja" role="doc-biblioref">Aust and Barth 2022</a>)</span>, <em>purrr</em> <span class="citation" data-cites="R-purrr">(Version 1.0.1; <a href="#ref-R-purrr" role="doc-biblioref">Wickham and Henry 2023</a>)</span>, <em>readr</em> <span class="citation" data-cites="R-readr">(Version 2.1.4; <a href="#ref-R-readr" role="doc-biblioref">Wickham, Hester, and Bryan 2023</a>)</span>, <em>stringr</em> <span class="citation" data-cites="R-stringr">(Version 1.5.0; <a href="#ref-R-stringr" role="doc-biblioref">Wickham 2022</a>)</span>, <em>tibble</em> <span class="citation" data-cites="R-tibble">(Version 3.2.1; <a href="#ref-R-tibble" role="doc-biblioref">Müller and Wickham 2022</a>)</span>, <em>tidyr</em> <span class="citation" data-cites="R-tidyr">(Version 1.3.0; <a href="#ref-R-tidyr" role="doc-biblioref">Wickham, Vaughan, and Girlich 2023</a>)</span>, <em>tidyverse</em> <span class="citation" data-cites="R-tidyverse">(Version 2.0.0; <a href="#ref-R-tidyverse" role="doc-biblioref">Wickham et al. 2019</a>)</span>, <em>tinylabels</em> <span class="citation" data-cites="R-tinylabels">(Version 0.2.3; <a href="#ref-R-tinylabels" role="doc-biblioref">Barth 2022</a>)</span>, and <em>xtable</em> <span class="citation" data-cites="R-xtable">(Version 1.8.4; <a href="#ref-R-xtable" role="doc-biblioref">Dahl et al. 2019</a>)</span> for all our analyses.</p>
</section>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<section id="experiment-1b-amazon-mechanical-turk-masters" class="level3">
<h3 class="anchored" data-anchor-id="experiment-1b-amazon-mechanical-turk-masters">Experiment 1b: Amazon Mechanical Turk Master’s</h3>
</section>
<section id="post-hoc-power-analysis" class="level3">
<h3 class="anchored" data-anchor-id="post-hoc-power-analysis">Post-hoc power analysis</h3>
<p>The results from Experiment 1b were used to conduct a simulation-based post-hoc power analysis. The purpose of the power analysis was to estimate the smallest effect size of interest that the design was capable of detecting.</p>
</section>
<section id="experiment-1c-brooklyn-college-sona" class="level3">
<h3 class="anchored" data-anchor-id="experiment-1c-brooklyn-college-sona">Experiment 1c: Brooklyn College SONA</h3>
</section>
</section>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion</h2>
</section>
</section>
<section id="general-discussion" class="level1">
<h1>General Discussion</h1>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
</section>
<section id="references" class="level1">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-custom-style="Bibliography" data-entry-spacing="0" role="list">
<div id="ref-R-papaja" class="csl-entry" role="listitem">
Aust, Frederik, and Marius Barth. 2022. <em><span class="nocase">papaja</span>: <span>Prepare</span> Reproducible <span>APA</span> Journal Articles with <span>R Markdown</span></em>. <a href="https://github.com/crsh/papaja">https://github.com/crsh/papaja</a>.
</div>
<div id="ref-R-tinylabels" class="csl-entry" role="listitem">
Barth, Marius. 2022. <em><span class="nocase">tinylabels</span>: Lightweight Variable Labels</em>. <a href="https://cran.r-project.org/package=tinylabels">https://cran.r-project.org/package=tinylabels</a>.
</div>
<div id="ref-R-xtable" class="csl-entry" role="listitem">
Dahl, David B., David Scott, Charles Roosen, Arni Magnusson, and Jonathan Swinton. 2019. <em>Xtable: Export Tables to LaTeX or HTML</em>. <a href="https://CRAN.R-project.org/package=xtable">https://CRAN.R-project.org/package=xtable</a>.
</div>
<div id="ref-R-data.table" class="csl-entry" role="listitem">
Dowle, Matt, and Arun Srinivasan. 2022. <em>Data.table: Extension of ‘Data.frame‘</em>. <a href="https://CRAN.R-project.org/package=data.table">https://CRAN.R-project.org/package=data.table</a>.
</div>
<div id="ref-R-lubridate" class="csl-entry" role="listitem">
Grolemund, Garrett, and Hadley Wickham. 2011. <span>“Dates and Times Made Easy with <span class="nocase">lubridate</span>.”</span> <em>Journal of Statistical Software</em> 40 (3): 1–25. <a href="https://www.jstatsoft.org/v40/i03/">https://www.jstatsoft.org/v40/i03/</a>.
</div>
<div id="ref-R-tibble" class="csl-entry" role="listitem">
Müller, Kirill, and Hadley Wickham. 2022. <em>Tibble: Simple Data Frames</em>. <a href="https://CRAN.R-project.org/package=tibble">https://CRAN.R-project.org/package=tibble</a>.
</div>
<div id="ref-R-jsonlite" class="csl-entry" role="listitem">
Ooms, Jeroen. 2014. <span>“The Jsonlite Package: A Practical and Consistent Mapping Between JSON Data and r Objects.”</span> <em>arXiv:1403.2805 [Stat.CO]</em>. <a href="https://arxiv.org/abs/1403.2805">https://arxiv.org/abs/1403.2805</a>.
</div>
<div id="ref-R-base" class="csl-entry" role="listitem">
R Core Team. 2022. <em>R: A Language and Environment for Statistical Computing</em>. Vienna, Austria: R Foundation for Statistical Computing. <a href="https://www.R-project.org/">https://www.R-project.org/</a>.
</div>
<div id="ref-rogers_self-reference_1977" class="csl-entry" role="listitem">
Rogers, Timothy B., Nicholas A. Kuiper, and William S. Kirker. 1977. <span>“Self-Reference and the Encoding of Personal Information.”</span> <em>Journal of Personality and Social Psychology</em> 35 (9): 677. <a href="https://doi.org/10.1037/0022-3514.35.9.677">https://doi.org/10.1037/0022-3514.35.9.677</a>.
</div>
<div id="ref-R-ggplot2" class="csl-entry" role="listitem">
Wickham, Hadley. 2016. <em>Ggplot2: Elegant Graphics for Data Analysis</em>. Springer-Verlag New York. <a href="https://ggplot2.tidyverse.org">https://ggplot2.tidyverse.org</a>.
</div>
<div id="ref-R-stringr" class="csl-entry" role="listitem">
———. 2022. <em>Stringr: Simple, Consistent Wrappers for Common String Operations</em>. <a href="https://CRAN.R-project.org/package=stringr">https://CRAN.R-project.org/package=stringr</a>.
</div>
<div id="ref-R-forcats" class="csl-entry" role="listitem">
———. 2023. <em>Forcats: Tools for Working with Categorical Variables (Factors)</em>. <a href="https://CRAN.R-project.org/package=forcats">https://CRAN.R-project.org/package=forcats</a>.
</div>
<div id="ref-R-tidyverse" class="csl-entry" role="listitem">
Wickham, Hadley, Mara Averick, Jennifer Bryan, Winston Chang, Lucy D’Agostino McGowan, Romain François, Garrett Grolemund, et al. 2019. <span>“Welcome to the <span class="nocase">tidyverse</span>.”</span> <em>Journal of Open Source Software</em> 4 (43): 1686. <a href="https://doi.org/10.21105/joss.01686">https://doi.org/10.21105/joss.01686</a>.
</div>
<div id="ref-R-dplyr" class="csl-entry" role="listitem">
Wickham, Hadley, Romain François, Lionel Henry, Kirill Müller, and Davis Vaughan. 2023. <em>Dplyr: A Grammar of Data Manipulation</em>. <a href="https://CRAN.R-project.org/package=dplyr">https://CRAN.R-project.org/package=dplyr</a>.
</div>
<div id="ref-R-purrr" class="csl-entry" role="listitem">
Wickham, Hadley, and Lionel Henry. 2023. <em>Purrr: Functional Programming Tools</em>. <a href="https://CRAN.R-project.org/package=purrr">https://CRAN.R-project.org/package=purrr</a>.
</div>
<div id="ref-R-readr" class="csl-entry" role="listitem">
Wickham, Hadley, Jim Hester, and Jennifer Bryan. 2023. <em>Readr: Read Rectangular Text Data</em>. <a href="https://CRAN.R-project.org/package=readr">https://CRAN.R-project.org/package=readr</a>.
</div>
<div id="ref-R-tidyr" class="csl-entry" role="listitem">
Wickham, Hadley, Davis Vaughan, and Maximilian Girlich. 2023. <em>Tidyr: Tidy Messy Data</em>. <a href="https://CRAN.R-project.org/package=tidyr">https://CRAN.R-project.org/package=tidyr</a>.
</div>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        for (let i = 0; i < 2; i++) {
          container.appendChild(note.children[i].cloneNode(true));
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>